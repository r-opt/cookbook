[["index.html", "Practical Discrete Optimization in R: A Cookbook Chapter 1 Introduction And Setup", " Practical Discrete Optimization in R: A Cookbook Dirk Schumacher 2021-02-13 Chapter 1 Introduction And Setup The goal of this book is to compile a list of practical Operations Research problems that can be solved with rmpk. During initial package development it acts as early documentation and also a big integration test to guide further development. It currently is assumed you already know a bit about the theory of mixed integer programming (I will write something about it at a later point in time). Each chapter is a broad problem category (like Scheduling or Puzzles) and contains a set of problems that help you get started. In order to run the examples in this book, you need the rmpk package together with a solver. options(repos = c( ropt = &quot;https://r-opt.r-universe.dev&quot;, CRAN = &quot;https://cloud.r-project.org&quot;)) install.packages(&quot;rmpk&quot;) # modelling install.packages(&quot;ROIoptimzer&quot;) # ROI optimizer install.packages(&quot;ROI.plugin.glpk&quot;) # Bindings to GLPK "],["puzzles.html", "Chapter 2 Puzzles 2.1 Solve Sudokus using MILP", " Chapter 2 Puzzles Here we have classical examples like Sudokus, Graphic Coloring etc. 2.1 Solve Sudokus using MILP In this vignettes we will solve Sudoku puzzles using MILP. Sudoku in its most popular form is a constraint satisfaction problem and by setting the objective function to \\(0\\) you transform the optimization problem into a pure constraint satistication problem. In this document we will consider Sudokus in a 9x9 grid with 3x3 sub-matrices. Of course you can formulate an objective function as well that directs the solver towards solutions maximizing a certain linear function. 2.1.1 The model The idea is to introduce a binary variable \\(x\\) with three indexes \\(i, j, k\\) that is \\(1\\) if and only if the number \\(k\\) is in cell \\(i, j\\). library(rmpk) library(ROI.plugin.glpk) n &lt;- 9 model &lt;- optimization_model(ROI_optimizer(&quot;glpk&quot;)) # The number k stored in position i,j x &lt;- model$add_variable(&quot;x&quot;, i = 1:n, j = 1:n, k = 1:9, type = &quot;binary&quot;) # no objective model$set_objective(0) # only one number can be assigned per cell model$add_constraint(sum_expr(x[i, j, k], k = 1:9) == 1, i = 1:n, j = 1:n) # each number is exactly once in a row model$add_constraint(sum_expr(x[i, j, k], j = 1:n) == 1, i = 1:n, k = 1:9) # each number is exactly once in a column model$add_constraint(sum_expr(x[i, j, k], i = 1:n) == 1, j = 1:n, k = 1:9) # each 3x3 square must have all numbers model$add_constraint(sum_expr(x[i, j, k], i = 1:3 + sx, j = 1:3 + sy) == 1, sx = seq(0, n - 3, 3), sy = seq(0, n - 3, 3), k = 1:9) model ## MIP Model: ## Variables: 729 ## Constraints: 324 2.1.2 Solve the model We will use glpk to solve the above model. Note that we haven’t fixed any numbers to specific values. That means that the solver will find a valid sudoku without any prior hints. model$optimize() library(dplyr) # the following dplyr statement plots a 9x9 matrix model$get_variable_value(x[i,j,k]) %&gt;% filter(value &gt; 0) %&gt;% select(i, j, k) %&gt;% tidyr::spread(j, k) %&gt;% select(-i) ## 1 2 3 4 5 6 7 8 9 ## 1 4 2 3 5 7 8 1 9 6 ## 2 1 7 5 9 3 6 4 8 2 ## 3 9 8 6 2 1 4 7 3 5 ## 4 8 6 4 1 5 9 3 2 7 ## 5 3 5 9 6 2 7 8 1 4 ## 6 2 1 7 8 4 3 5 6 9 ## 7 7 9 1 3 6 5 2 4 8 ## 8 6 4 2 7 8 1 9 5 3 ## 9 5 3 8 4 9 2 6 7 1 If you want to solve a concrete sudoku you can fix certain cells to specific values. For example here we solve a sudoku that has the sequence from 1 to 9 in the first 3x3 matrix fixed. model$add_constraint(x[1, 1, 1] == 1) model$add_constraint(x[1, 2, 2] == 1) model$add_constraint(x[1, 3, 3] == 1) model$add_constraint(x[2, 1, 4] == 1) model$add_constraint(x[2, 2, 5] == 1) model$add_constraint(x[2, 3, 6] == 1) model$add_constraint(x[3, 1, 7] == 1) model$add_constraint(x[3, 2, 8] == 1) model$add_constraint(x[3, 3, 9] == 1) model$optimize() model$get_variable_value(x[i,j,k]) %&gt;% filter(value &gt; 0) %&gt;% select(i, j, k) %&gt;% tidyr::spread(j, k) %&gt;% select(-i) ## 1 2 3 4 5 6 7 8 9 ## 1 1 2 3 5 8 4 9 7 6 ## 2 4 5 6 9 7 3 8 2 1 ## 3 7 8 9 2 1 6 3 5 4 ## 4 3 1 5 6 4 7 2 9 8 ## 5 9 7 4 1 2 8 5 6 3 ## 6 8 6 2 3 9 5 4 1 7 ## 7 2 4 8 7 5 1 6 3 9 ## 8 5 3 1 8 6 9 7 4 2 ## 9 6 9 7 4 3 2 1 8 5 "],["routing-problems.html", "Chapter 3 Routing Problems 3.1 The Traveling Salesperson Problem using MILP", " Chapter 3 Routing Problems 3.1 The Traveling Salesperson Problem using MILP We describe how to solve a TSP using rmpk. Wikipedia gives the following definition: The travelling salesman problem (TSP) asks the following question: Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city? Also that Wikipedia article is a good starting point if you want to know more about the topic. With the basic definition you have a set of verticies (cities) and a set of edges (connection between cities). Each edge has an associated distance \\(d &gt; 0\\). That distance could be travel time, distance in km or the monetary cost associated with traveling from one city to another. Restrictions on the distances lead to special cases of the problem. For example the metric-TSP requires that the triangle inequality holds for all triples of edges. In this vignette we will construct a TSP with random points within an Euclidean space. 3.1.1 Setting First let us import some librarys library(knitr) library(dplyr) library(ggplot2) The number of cities: n &lt;- 10 Boundary of our Euclidean space: # from 0 to ... max_x &lt;- 500 max_y &lt;- 500 Some random cities: set.seed(123456) cities &lt;- data.frame(id = 1:n, x = runif(n, max = max_x), y = runif(n, max = max_y)) ggplot(cities, aes(x, y)) + geom_point() Now the distance matrix distance &lt;- as.matrix(dist(select(cities, x, y), diag = TRUE, upper = TRUE)) 3.1.2 Model formulation There are essential two prominent ways to model a TSP as a MILP. One is to formulate the full model using the Miller–Tucker–Zemlin (MTZ) formulation and the other option is to use the so-called sub-tour elimination constraints .1 The first formulation is fairly compact (quadratic many constraints and variables) but is not suitable anymore when n gets larger. The second formulation has exponential many constraints at most, but can solve larger TSPs due to the better LP relaxation. The idea of the latter approach is add constraints to the model during the solution process as soon as a solution was found that contains a sub-tour. For solution strategies like this solvers usually offer callbacks that let’s you modify the model during the the branch-and-cut process. Therefor we will use the MTZ formulation and solve a fairly small TSP. library(rmpk) library(ROI.plugin.glpk) model &lt;- optimization_model(ROI_optimizer(&quot;glpk&quot;)) # we create a variable that is 1 iff we travel from city i to j x &lt;- model$add_variable(&quot;x&quot;, i = 1:n, j = 1:n, type = &quot;integer&quot;, lb = 0, ub = 1) # a helper variable for the MTZ formulation of the tsp u &lt;- model$add_variable(&quot;u&quot;, i = 1:n, lb = 1, ub = n) # minimize travel distance model$set_objective(sum_expr(distance[i, j] * x[i, j], i = 1:n, j = 1:n), &quot;min&quot;) # you cannot go to the same city model$set_bounds(x[i, i], ub = 0, i = 1:n) # leave each city model$add_constraint(sum_expr(x[i, j], j = 1:n) == 1, i = 1:n) # visit each city model$add_constraint(sum_expr(x[i, j], i = 1:n) == 1, j = 1:n) # ensure no subtours (arc constraints) model$add_constraint(u[i] &gt;= 2, i = 2:n) model$add_constraint(u[i] - u[j] + 1 &lt;= (n - 1) * (1 - x[i, j]), i = 2:n, j = 2:n) model ## MIP Model: ## Variables: 110 ## Constraints: 110 3.1.3 Results This model can now be solved by one of the many solver libraries. Here we will use GLPK. model$optimize() To extract the solution we can use get_variable_value method that will return a data.frame which we can further be used with tidyverse packages. solution &lt;- model$get_variable_value(x[i, j]) %&gt;% filter(value &gt; 0) kable(head(solution, 3)) name i j value x 6 4 1 x 10 6 1 x 7 1 1 Now we need to link back the indexes in our model with the actual cities. paths &lt;- select(solution, i, j) %&gt;% rename(from = i, to = j) %&gt;% mutate(trip_id = row_number()) %&gt;% tidyr::gather(property, idx_val, from:to) %&gt;% mutate(idx_val = as.integer(idx_val)) %&gt;% inner_join(cities, by = c(&quot;idx_val&quot; = &quot;id&quot;)) kable(head(arrange(paths, trip_id), 4)) trip_id property idx_val x y 1 from 6 99.17237 447.9782 1 to 4 170.77835 440.4243 2 from 10 83.78474 388.6032 2 to 6 99.17237 447.9782 And plot it: ggplot(cities, aes(x, y)) + geom_point() + geom_line(data = paths, aes(group = trip_id)) + ggtitle(paste0(&quot;Optimal route with cost: &quot;, round(model$objective_value(), 2))) "],["references.html", "Chapter 4 References", " Chapter 4 References "]]
